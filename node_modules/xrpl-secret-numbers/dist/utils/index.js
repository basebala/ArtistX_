'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSecretString = exports.checkChecksum = exports.calculateChecksum = exports.secretToEntropy = exports.entropyToSecret = exports.randomSecret = exports.randomEntropy = void 0;
var assert_1 = __importDefault(require("assert"));
var brorand_1 = __importDefault(require("brorand"));
function randomEntropy() {
    return Buffer.from(brorand_1.default(16));
}
exports.randomEntropy = randomEntropy;
function calculateChecksum(position, value) {
    return value * (position * 2 + 1) % 9;
}
exports.calculateChecksum = calculateChecksum;
function checkChecksum(position, value, checksum) {
    if (typeof value === 'string') {
        assert_1.default.strictEqual(value.length, 6);
        checksum = parseInt(value.slice(5), 10);
        value = parseInt(value.slice(0, 5), 10);
    }
    return value * (position * 2 + 1) % 9 === checksum;
}
exports.checkChecksum = checkChecksum;
function entropyToSecret(entropy) {
    var length = Array(Math.ceil(entropy.length / 2));
    var chunks = Array.apply(null, length).map(function (a, b) {
        return entropy.slice(b * 2, ++b * 2);
    }).map(function (r, i) {
        var no = parseInt(r.toString('hex'), 16);
        var fill = '0'.repeat(5 - String(no).length);
        return fill + String(no) + String(calculateChecksum(i, no));
    });
    assert_1.default.equal(chunks.length, 8);
    return chunks;
}
exports.entropyToSecret = entropyToSecret;
function randomSecret() {
    return entropyToSecret(randomEntropy());
}
exports.randomSecret = randomSecret;
function secretToEntropy(secret) {
    return Buffer.concat(secret.map(function (r, i) {
        var no = Number(r.slice(0, 5));
        var checksum = Number(r.slice(5));
        try {
            assert_1.default.strictEqual(r.length, 6);
        }
        catch (e) {
            throw new Error('Invalid secret: number invalid');
        }
        try {
            assert_1.default.strictEqual(checkChecksum(i, no, checksum), true);
        }
        catch (e) {
            throw new Error('Invalid secret part: checksum invalid');
        }
        var hex = ('0000' + no.toString(16)).slice(-4);
        return Buffer.from(hex, 'hex');
    }));
}
exports.secretToEntropy = secretToEntropy;
function parseSecretString(secret) {
    secret = secret.replace(/[^0-9]/g, '');
    if (secret.length !== 48) {
        throw new Error('Invalid secret string (should contain 8 blocks of 6 digits');
    }
    return Array.apply(null, Array(8)).map(function (a, i) {
        return secret.slice(i * 6, (i + 1) * 6);
    });
}
exports.parseSecretString = parseSecretString;
